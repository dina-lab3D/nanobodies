from tensorflow.keras.models import load_model
import argparse
import numpy as np
from NanoNet_utils import generate_input, remove_pad, get_seq
import cdr_annot
import os
from Bio.PDB import *
import re


DIST_STD = 0.63  # =0.63
OMEGA_STD = 0.6  # =0.424
THETA_STD = 0.3  # =0.3
PHI_STD = 0.22  # =0.22


def write_const_dist(const_file, constraints, cdr3_s, seq):
    """
    Writes the distance constraints into cons_file
    """
    length = len(constraints)
    for i in range(length):
        for j in range(i+1, length):  # symmetry
            atom_i = i + cdr3_s
            atom_j = j + cdr3_s
            atom_i_type = 'CA' if seq[atom_i] == 'G' else 'CB'  # GLY
            atom_j_type = 'CA' if seq[atom_j] == 'G' else 'CB'  # GLY
            atom_i += 1  # pdb numbering starts from 1
            atom_j += 1  # pdb numbering starts from 1

            const_file.write("AtomPair {} {} {} {} HARMONIC {:.5f} {}\n".format(atom_i_type, atom_i, atom_j_type, atom_j, constraints[i,j], DIST_STD))


def write_const_omega(const_file, constraints, cdr3_s, seq):
    """
    Writes the omega dihedral constraints into cons_file
    """
    length = len(constraints)
    for i in range(length):
        for j in range(i + 1, length):  # symmetry
            atom_i = i + cdr3_s
            atom_j = j + cdr3_s
            if seq[atom_i] == 'G' or seq[atom_j] == 'G':  # GLY
                continue
            atom_i += 1  # pdb numbering starts from 1
            atom_j += 1  # pdb numbering starts from 1

            const_file.write("Dihedral CA {} CB {} CB {} CA {} CIRCULARHARMONIC {:.5f} {}\n".format(atom_i, atom_i, atom_j, atom_j, constraints[i, j], OMEGA_STD))


def write_const_theta(const_file, constraints, cdr3_s, seq):
    """
    Writes the theta dihedral constraints into cons_file
    """
    length = len(constraints)
    for i in range(length):
        for j in range(length):
            if i == j:  # same atom...
                continue
            atom_i = i + cdr3_s
            atom_j = j + cdr3_s
            if seq[atom_i] == 'G' or seq[atom_j] == 'G':  # GLY
                continue
            atom_i += 1  # pdb numbering starts from 1
            atom_j += 1  # pdb numbering starts from 1

            const_file.write("Dihedral N {} CA {} CB {} CB {} CIRCULARHARMONIC {:.5f} {}\n".format(atom_i, atom_i, atom_i, atom_j, constraints[i, j], THETA_STD))


def write_const_phi(const_file, constraints, cdr3_s, seq):
    """
    Writes the phi angle constraints into cons_file
    """
    length = len(constraints)
    for i in range(length):
        for j in range(length):
            if i == j:  # same atom...
                continue
            atom_i = i + cdr3_s
            atom_j = j + cdr3_s
            if seq[atom_i] == 'G' or seq[atom_j] == 'G':  # GLY
                continue
            atom_i += 1  # pdb numbering starts from 1
            atom_j += 1  # pdb numbering starts from 1

            const_file.write("Angle CA {} CB {} CB {} CIRCULARHARMONIC {:.5f} {}\n".format(atom_i, atom_i, atom_j, constraints[i, j], PHI_STD))


def write_const_file(name, sequence, restraints_matrix):
    """
    writes the a constraints file to use in Rosetta H3 modeling
    :param name: pdb name
    :param sequence: nb sequence (String)
    :param restraints_matrix: restraints matrix generated by NanoNet
    """
    distance_restraints = remove_pad(restraints_matrix[0][0,:,:,0], sequence) * 10  # we divided by factor 10 in NanoNet
    omega_restraints = np.arctan2(remove_pad(restraints_matrix[1][0, :, :, 1], sequence), remove_pad(restraints_matrix[1][0, :, :, 0], sequence))  # angle = arctan(sin, cos)
    thetha_restraints = np.arctan2(remove_pad(restraints_matrix[2][0, :, :, 1], sequence), remove_pad(restraints_matrix[2][0, :, :, 0], sequence))
    phis_restraints = np.arctan2(remove_pad(restraints_matrix[3][0, :, :, 1], sequence), remove_pad(restraints_matrix[3][0, :, :, 0], sequence))

    cdr_s, cdr_e = cdr_annotation.find_cdr3(sequence)
    # print(cdr_e - cdr_s+1)
    with open(name + "_constraints", 'w') as const_file:
        write_const_dist(const_file, distance_restraints, cdr_s, sequence)
        write_const_omega(const_file, omega_restraints, cdr_s, sequence)
        write_const_theta(const_file, thetha_restraints, cdr_s, sequence)
        write_const_phi(const_file, phis_restraints, cdr_s, sequence)


if __name__ == '__main__':
    """
    creates a constraints file to use in Rosetta H3 modeling (in "<nb_name>_constraints")
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("nb_pdb", help="nb pdb file generated by Rosetta antibody (H - heavy chain)")
    parser.add_argument("NanoNet", help="trained NanoNet model")
    args = parser.parse_args()
    pdb_name = args.nb_pdb.split(".")[0]
    nano_net_model = load_model(args.NanoNet)

    model = PDBParser().get_structure(args.nb_pdb, args.nb_pdb)[0]["H"]
    nb_seq, aa_chain = get_seq(model)
    restraints = nano_net_model.predict(np.array([generate_input(nb_seq)]))
    write_const_file(pdb_name, nb_seq, restraints)
